use crate::crt0::allocator::{AllocatorOps, AllocatorState, Address};
use core::num::traits::BitSize;
use core::traits::BitAnd;
use crate::crt0::utils::t_to_buffer;
use super::get_allocator;
use crate::integer::{u24::u24, u40::u40};

/// Store a portion of data at the provided address plus the provided offset. The number of stored
/// bytes is equal to the size of T. `offset` must be non-negative and must fit in u64.
///
/// See compiler_rt::crt0::allocator::AllocatorOps::store for details about storing to memory.
///
/// This is the implementation of the `__llvm_store_*` polyfills logic. It exists so that it can be
/// unit-tested with a mock allocator. The polyfills are wrappers over this function and they get
/// the actual allocator with the getter generated by Hieratika.
///
/// This is a generic implementation for every data type. Its specialized versions are defined in
/// this file.
fn store<T, +BitAnd<T>, +BitSize<T>, +Copy<T>, +Div<T>, +Drop<T>, +Into<u8, T>, +TryInto<T, u8>>(
    ref allocator: AllocatorState, value: T, address: Address, offset: i64,
) {
    let store_address: Address = address + offset.try_into().expect('offset does not fit in u64');
    let buffer = t_to_buffer::<T>(value);
    allocator.store(store_address, @buffer);
}

#[cfg(test)]
mod test {
    use super::store;
    use crate::crt0::allocator::{Allocator, AllocatorOps, ByteCount};
    use crate::crt0::utils::{BITS_IN_BYTE, buffer_to_t};
    use core::num::traits::{BitSize, OverflowingMul};
    use core::traits::{BitOr, BitAnd};
    use core::fmt::Debug;
    use crate::integer::{u24::u24, u40::u40};

    /// Make sure the input array of bytes can be serialized to a single variable of type T.
    fn assert_bytes<
        T, +Debug<T>, +Drop<T>, +PartialEq<T>, +OverflowingMul<T>, +Into<u8, T>, +BitOr<T>,
    >(
        bytes: @Array<u8>, value: T,
    ) {
        let serialized_bytes: T = buffer_to_t(bytes);
        assert_eq!(value, serialized_bytes);
    }

    /// The actual test case, generalized over the input data type.
    ///
    /// Store a single type T variable with the first sizeof(T) bytes of memory. Then load the first
    /// sizeof(T) bytes of memory and check if they are equal to the input value.
    fn test_store_t<
        T,
        +Debug<T>,
        +PartialEq<T>,
        +OverflowingMul<T>,
        +BitOr<T>,
        +BitAnd<T>,
        +BitSize<T>,
        +Copy<T>,
        +Div<T>,
        +Drop<T>,
        +Into<u8, T>,
        +TryInto<T, u8>,
    >(
        data: T,
    ) {
        // Instantiate the allocator.
        let mut allocator = Allocator::new();

        // Calculate how many bytes we need to store.
        let sizeof_data: ByteCount = (BitSize::<T>::bits() / BITS_IN_BYTE).into();
        // We store at the address 0x00.
        let address = 0;
        let offset = 0;

        store::<T>(ref allocator, data, address, offset);

        // Load the same amount of data from the same address and see if equals the input value.
        let loaded = allocator.load(address, sizeof_data);
        assert_bytes(@loaded, data);
    }

    #[test]
    /// Store a single u8 variable with the first byte of memory.
    fn store_u8() {
        test_store_t::<u8>(0x00);
    }

    #[test]
    /// Load a single u16 variable with the first 2 bytes of memory.
    fn store_u16() {
        test_store_t::<u16>(0x0100);
    }

    #[test]
    /// Load a single u16 variable with the first 3 bytes of memory.
    fn store_u24() {
        test_store_t::<u24>(0x020100_u128.try_into().unwrap());
    }

    #[test]
    /// Load a single u32 variable with the first 4 bytes of memory.
    fn store_u32() {
        test_store_t::<u32>(0x03020100);
    }

    #[test]
    /// Load a single u40 variable with the first 5 bytes of memory.
    fn store_u40() {
        test_store_t::<u40>(0x0403020100_u128.try_into().unwrap());
    }

    #[test]
    /// Load a single u64 variable with the first 8 bytes of memory.
    fn store_u64() {
        test_store_t::<u64>(0x0706050403020100);
    }

    #[test]
    /// Load a single u128 variable with the first 16 bytes of memory.
    fn store_u128() {
        test_store_t::<u128>(0x0f0e0d0c0b0a09080706050403020100);
    }
}

pub fn __llvm_store_b_p_l_v(value: u8, address: Address, offset: i64) {
    // This must be <u8> because:
    //   Trait has no implementation in context:
    //   core::traits::BitAnd::<core::integer::i8>.
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

pub fn __llvm_store_z_p_l_v(value: u16, address: Address, offset: i64) {
    // This must be <u16> because:
    //   Trait has no implementation in context:
    //   core::traits::BitAnd::<core::integer::i16>.
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

pub fn __llvm_store_x_p_l_v(value: u24, address: Address, offset: i64) {
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

pub fn __llvm_store_i_p_l_v(value: u32, address: Address, offset: i64) {
    // This must be <u32> because:
    //   Trait has no implementation in context:
    //   core::traits::BitAnd::<core::integer::i32>.
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

pub fn __llvm_store_n_p_l_v(value: u40, address: Address, offset: i64) {
    // This must be <u64> because:
    //   Trait has no implementation in context:
    //   core::traits::BitAnd::<core::integer::i64>.
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

pub fn __llvm_store_l_p_l_v(value: u64, address: Address, offset: i64) {
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

pub fn __llvm_store_o_p_l_v(value: u128, address: Address, offset: i64) {
    // This must be <u128> because:
    //   Trait has no implementation in context:
    //   core::traits::BitAnd::<core::integer::i128>.
    let mut allocator = get_allocator().unbox();
    store(ref allocator, value, address, offset);
}

