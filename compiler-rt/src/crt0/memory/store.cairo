use crate::rtstate::RTState;
use crate::crt0::allocator::{AllocatorOps, AllocatorState, Address};
use core::num::traits::BitSize;
use core::traits::BitAnd;
use crate::crt0::utils::t_to_buffer;

use crate::integer::{u24::u24, u40::u40, u48::u48};

/// Store a portion of data at the provided address plus the provided offset. The number of stored
/// bytes is equal to the size of T. `offset` must be non-negative and must fit in u64.
///
/// See compiler_rt::crt0::allocator::AllocatorOps::store for details about storing to memory.
///
/// This is the implementation of the `__llvm_store_*` polyfills logic. It exists so that it can be
/// unit-tested with a mock allocator. The polyfills are wrappers over this function and they get
/// the actual allocator with the getter generated by Hieratika.
///
/// This is a generic implementation for every data type. Its specialized versions are defined in
/// this file.
pub fn store<
    T,
    +BitAnd<T>,
    +BitSize<T>,
    +Copy<T>,
    +Div<T>,
    +Drop<T>,
    +Into<u8, T>,
    +TryInto<T, u8>,
    +TryInto<u128, T>,
>(
    ref allocator: AllocatorState, value: u128, address: Address, offset: u128,
) {
    let store_address: Address = address + offset.try_into().expect('offset does not fit in u64');
    let buffer = t_to_buffer::<T>(value.try_into().expect('value does not fit in T'));
    allocator.store(store_address, @buffer);
}

#[cfg(test)]
mod test {
    use super::store;
    use crate::crt0::allocator::{Allocator, AllocatorOps, ByteCount};
    use crate::crt0::utils::{BITS_IN_BYTE, buffer_to_t};
    use core::num::traits::{BitSize, OverflowingMul};
    use core::traits::{BitOr, BitAnd};
    use core::fmt::Debug;
    use crate::integer::{u24::u24, u40::u40, u48::u48};

    /// Make sure the input array of bytes can be serialized to a single variable of type T.
    fn assert_bytes<
        T, +Debug<T>, +Drop<T>, +PartialEq<T>, +OverflowingMul<T>, +Into<u8, T>, +BitOr<T>,
    >(
        bytes: @Array<u8>, value: T,
    ) {
        let serialized_bytes: T = buffer_to_t(bytes);
        assert_eq!(value, serialized_bytes);
    }

    /// The actual test case, generalized over the input data type.
    ///
    /// Store a single type T variable with the first sizeof(T) bytes of memory. Then load the first
    /// sizeof(T) bytes of memory and check if they are equal to the input value.
    fn test_store_t<
        T,
        +Debug<T>,
        +PartialEq<T>,
        +OverflowingMul<T>,
        +BitOr<T>,
        +BitAnd<T>,
        +BitSize<T>,
        +Copy<T>,
        +Div<T>,
        +Drop<T>,
        +Into<u8, T>,
        +TryInto<T, u8>,
        +TryInto<u128, T>,
    >(
        data: u128,
    ) {
        // Instantiate the allocator.
        let mut allocator = Allocator::new();

        // Calculate how many bytes we need to store.
        let sizeof_data: ByteCount = (BitSize::<T>::bits() / BITS_IN_BYTE).into();
        // We store at the address 0x00.
        let address = 0;
        let offset = 0;

        store::<T>(ref allocator, data, address, offset);

        // Load the same amount of data from the same address and see if equals the input value.
        let loaded = allocator.load(address, sizeof_data);
        assert_bytes(@loaded, data);
    }

    #[test]
    /// Store a single u8 variable with the first byte of memory.
    fn store_u8() {
        test_store_t::<u8>(0x00);
    }

    #[test]
    /// Store a single u16 variable with the first 2 bytes of memory.
    fn store_u16() {
        test_store_t::<u16>(0x0100);
    }

    #[test]
    /// Store a single u24 variable with the first 3 bytes of memory.
    fn store_u24() {
        test_store_t::<u24>(0x020100);
    }

    #[test]
    /// Store a single u32 variable with the first 4 bytes of memory.
    fn store_u32() {
        test_store_t::<u32>(0x03020100);
    }

    #[test]
    /// Store a single u40 variable with the first 5 bytes of memory.
    fn store_u40() {
        test_store_t::<u40>(0x0403020100);
    }

    #[test]
    /// Store a single u48 variable with the first 5 bytes of memory.
    fn store_u48() {
        test_store_t::<u48>(0x050403020100);
    }

    #[test]
    /// Store a single u64 variable with the first 8 bytes of memory.
    fn store_u64() {
        test_store_t::<u64>(0x0706050403020100);
    }

    #[test]
    /// Store a single u128 variable with the first 16 bytes of memory.
    fn store_u128() {
        test_store_t::<u128>(0x0f0e0d0c0b0a09080706050403020100);
    }
}

pub fn __llvm_store_c_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    // As per LLVM Languge Reference:
    //   When writing a value of a type like i20 with a size that is not an integral number of
    //   bytes, it is unspecified what happens to the extra bits that do not belong to the type, but
    //   they will typically be overwritten
    //
    // Therefore, in this implementation writing a bool will write 1 byte of data, and the
    // remaining bits will be set to 0.
    let value: u128 = if value > 0 {
        1
    } else {
        0
    };
    __llvm_store_b_p_l_v(ref state, value, address, offset);
}

pub fn __llvm_store_b_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u8>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_z_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u16>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_x_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u24>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_i_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u32>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_n_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u40>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_k_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u48>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_l_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u64>(ref state.allocator, value, address, offset);
}

pub fn __llvm_store_p_p_l_v(ref state: RTState, value: Address, address: Address, offset: u128) {
    store::<Address>(ref state.allocator, value.into(), address, offset);
}

pub fn __llvm_store_o_p_l_v(ref state: RTState, value: u128, address: Address, offset: u128) {
    store::<u128>(ref state.allocator, value, address, offset);
}
