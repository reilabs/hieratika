use crate::rtstate::RTState;
use crate::crt0::allocator::{AllocatorOps, AllocatorState, Address, ByteCount};
use core::num::traits::{BitSize, OverflowingMul};
use core::traits::BitOr;
use crate::crt0::utils::{BITS_IN_BYTE, buffer_to_t};

use crate::integer::{u24::u24, u40::u40, u48::u48};

/// Load a portion of data from the provided address plus the provided offset and return them as a
/// single variable of type T. The number of loaded bytes is equal to the size of T. `offset` must
/// be non-negative and must fit in u64.
///
/// See compiler_rt::crt0::allocator::AllocatorOps::load for details about loading from memory.
///
/// This is the implementation of the `__llvm_load_*` polyfills logic. It exists so that it can be
/// unit-tested with a mock allocator. The polyfills are wrappers over this function and they get
/// the actual allocator with the getter generated by Hieratika.
///
/// This is a generic implementation for every data type. Its specialized versions
/// are defined in this file.
pub fn load<
    T, +BitSize<T>, +OverflowingMul<T>, +Into<u8, T>, +Into<T, u128>, +BitOr<T>, +PanicDestruct<T>,
>(
    ref allocator: AllocatorState, address: Address, offset: u128,
) -> u128 {
    let load_address: Address = address + offset.try_into().expect('offset does not fit in u64');
    let load_size: ByteCount = (BitSize::<T>::bits() / BITS_IN_BYTE).into();
    let data = allocator.load(load_address, load_size);
    buffer_to_t::<T>(@data).into()
}

#[cfg(test)]
mod test {
    use super::load;
    use crate::crt0::allocator::{Allocator, AllocatorOps, AllocatorState};
    use crate::integer::{u24::u24, u40::u40, u48::u48};

    /// Prepare allocator for the test suite.
    ///
    /// Instantiate the allocator, allocate a memory region and store a predefined array of bytes
    /// at the beginning of the allocated region. The test cases will load bytes from that region.
    fn get_allocator() -> Box<AllocatorState> {
        let mut allocator = Allocator::new();
        let address1 = allocator.allocate(32);
        #[cairofmt::skip]
        let array1 = array![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        ];
        allocator.store(address1, @array1);

        BoxTrait::new(allocator)
    }

    #[test]
    /// Load a single u8 variable with the first byte of memory.
    fn load_u8() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u8>(ref allocator, 0, 0);
        assert_eq!(data1, 0x00);
    }

    #[test]
    /// Load a single u16 variable with the first 2 bytes of memory.
    fn load_u16() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u16>(ref allocator, 0, 0);
        assert_eq!(data1, 0x0100);
    }

    #[test]
    /// Load a single u24 variable with the first 3 bytes of memory.
    fn load_u24() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u24>(ref allocator, 0, 0);
        assert_eq!(data1, 0x020100);
    }


    #[test]
    /// Load a single u32 variable with the first 4 bytes of memory.
    fn load_u32() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u32>(ref allocator, 0, 0);
        assert_eq!(data1, 0x03020100);
    }

    #[test]
    /// Load a single u40 variable with the first 5 bytes of memory.
    fn load_u40() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u40>(ref allocator, 0, 0);
        assert_eq!(data1, 0x0403020100);
    }

    #[test]
    /// Load a single u48 variable with the first 6 bytes of memory.
    fn load_u48() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u48>(ref allocator, 0, 0);
        assert_eq!(data1, 0x050403020100);
    }

    #[test]
    /// Load a single u64 variable with the first 8 bytes of memory.
    fn load_u64() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u64>(ref allocator, 0, 0);
        assert_eq!(data1, 0x0706050403020100);
    }

    #[test]
    /// Load a single u128 variable with the first 16 bytes of memory.
    fn load_u128() {
        let mut allocator = get_allocator().unbox();
        let data1 = load::<u128>(ref allocator, 0, 0);
        assert_eq!(data1, 0x0f0e0d0c0b0a09080706050403020100);
    }
}

pub fn __llvm_load_p_l_c(ref state: RTState, address: Address, offset: u128) -> u128 {
    // As per LLVM Languge Reference:
    //  When loading a value of a type like i20 with a size that is not an integral number of bytes,
    //  the result is undefined if the value was not originally written using a store of the same
    //  type
    //
    // Therefore, in this implementation loading a bool will load 1 byte of data and only LSB will
    // be returned. The remaining bits will be ignored.
    if __llvm_load_p_l_b(ref state, address, offset) & 0b1 == 0b1 {
        return 1;
    }

    return 0;
}

pub fn __llvm_load_p_l_b(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u8>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_z(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u16>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_x(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u24>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_i(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u32>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_n(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u40>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_k(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u48>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_l(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u64>(ref state.allocator, address, offset)
}

pub fn __llvm_load_p_l_p(ref state: RTState, address: Address, offset: u128) -> Address {
    load::<Address>(ref state.allocator, address, offset)
        .try_into()
        .expect('address does not fit in u64')
}

pub fn __llvm_load_p_l_o(ref state: RTState, address: Address, offset: u128) -> u128 {
    load::<u128>(ref state.allocator, address, offset)
}
