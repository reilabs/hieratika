use crate::rtstate::RTState;
use crate::crt0::allocator::{AllocatorOps, AllocatorState, Address, ByteCount};

/// Copy a block of memory from the source location to the destination location.
///
/// The first argument is a pointer to the destination, the second is a pointer to the source. The
/// third argument is an integer argument specifying the number of bytes to copy.
///
/// `llvm.memcpy.*` has also the fourth argument, a boolean indicating a volatile access. This
/// concept does not map to Cairo VM, therefore this argument is skipped from the generic
/// implementation of the operation. The polyfills have this argument for API compatibility, but it
/// remains unused.
///
/// See compiler_rt::crt0::allocator::AllocatorOps::load and ::store for details about loading from
/// and storing to memory.
///
/// This is the implementation of the `__llvm_memcpy_*` polyfills logic. It exists so that it can be
/// unit-tested with a mock allocator. The polyfills are wrappers over this function and they get
/// the actual allocator with the getter generated by Hieratika.
pub fn memcpy(ref allocator: AllocatorState, dest: Address, src: Address, len: u128) {
    if len == 0 {
        return;
    }

    // The underlying memory allocator operates on 64-bit addresses, therefore lengths larger than
    // u64::max are not supported.
    let len: ByteCount = len.try_into().expect('memcpy: length exceeds 64-bit');

    // As per LLVM Language Reference:
    //  The ‘llvm.memcpy.*’ intrinsics copy a block of memory from the source location to the
    //  destination location, which must either be equal or non-overlapping.
    if (src < dest && src + len > dest) || (dest < src && dest + len > src) {
        panic!("memcpy: overlapping memory regions");
    }

    allocator.store(dest, @allocator.load(src, len));
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::crt0::allocator::{Allocator, AllocatorOps};
    use core::num::traits::Bounded;

    /// Prepare allocator for the test suite.
    ///
    /// Instantiate the allocator, allocate a memory region and store a predefined array of bytes
    /// at the beginning of the allocated region. The test cases will load bytes from that region.
    fn get_allocator() -> Box<AllocatorState> {
        let mut allocator = Allocator::new();
        let address1 = allocator.allocate(256);
        #[cairofmt::skip]
        let array1 = array![
            0x1f, 0x2e, 0x3d, 0x4c, 0x5b, 0x6a, 0x79, 0x88, 0x97, 0xa6, 0xb5, 0xc4, 0xd3, 0xe2, 0xf1, 0x00,
            0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0x01,
            0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1, 0x02,
            0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72, 0x82, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2, 0x03,
            0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x93, 0xa3, 0xb3, 0xc3, 0xd3, 0xe3, 0xf3, 0x04,
            0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74, 0x84, 0x94, 0xa4, 0xb4, 0xc4, 0xd4, 0xe4, 0xf4, 0x05,
            0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75, 0x85, 0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5, 0x06,
            0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76, 0x86, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x07,
            0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7, 0x08,
            0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xa8, 0xb8, 0xc8, 0xd8, 0xe8, 0xf8, 0x09,
            0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79, 0x89, 0x99, 0xa9, 0xb9, 0xc9, 0xd9, 0xe9, 0xf9, 0x0a,
            0x1a, 0x2a, 0x3a, 0x4a, 0x5a, 0x6a, 0x7a, 0x8a, 0x9a, 0xaa, 0xba, 0xca, 0xda, 0xea, 0xfa, 0x0b,
            0x1b, 0x2b, 0x3b, 0x4b, 0x5b, 0x6b, 0x7b, 0x8b, 0x9b, 0xab, 0xbb, 0xcb, 0xdb, 0xeb, 0xfb, 0x0c,
            0x1c, 0x2c, 0x3c, 0x4c, 0x5c, 0x6c, 0x7c, 0x8c, 0x9c, 0xac, 0xbc, 0xcc, 0xdc, 0xec, 0xfc, 0x0d,
            0x1d, 0x2d, 0x3d, 0x4d, 0x5d, 0x6d, 0x7d, 0x8d, 0x9d, 0xad, 0xbd, 0xcd, 0xdd, 0xed, 0xfd, 0x0e,
            0x1e, 0x2e, 0x3e, 0x4e, 0x5e, 0x6e, 0x7e, 0x8e, 0x9e, 0xae, 0xbe, 0xce, 0xde, 0xee, 0xfe, 0x0f
        ];
        allocator.store(address1, @array1);

        BoxTrait::new(allocator)
    }

    /// The actual test case, generalized over data length.
    ///
    /// Copy a block of memory from the source to the destination using `memcpy`. Verify that the
    /// destination memory matches the source memory for the specified length.
    fn test_memcpy(dst: Address, src: Address, len: u128) {
        // Instantiate the allocator.
        let mut allocator = get_allocator().unbox();

        // Perform the memcpy operation.
        memcpy(ref allocator, dst, src, len);

        // Verify that the destination memory matches the source memory for the specified length.
        let src_value = allocator.load(src, len.try_into().unwrap());
        let dest_value = allocator.load(dst, len.try_into().unwrap());
        assert_eq!(src_value, dest_value);
    }

    #[test]
    #[should_panic(expected: 'memcpy: length exceeds 64-bit')]
    /// Test `memcpy` failing when the region is too big.
    fn too_long() {
        let len_max: u128 = Bounded::<u64>::MAX.into();
        test_memcpy(0, 0, len_max + 1);
    }

    #[test]
    #[should_panic(expected: "memcpy: overlapping memory regions")]
    /// Test `memcpy` failing when memory regions overlap.
    fn overlap() {
        test_memcpy(37, 21, 42);
    }

    #[test]
    /// Test `memcpy` when memory regions are equal.
    fn equal() {
        test_memcpy(100, 100, 42);
    }

    #[test]
    /// Test `memcpy` with a length of 0 bytes.
    fn memcpy_0() {
        test_memcpy(0, 0, 0);
    }

    #[test]
    /// Test `memcpy` with a length of 8 bytes.
    fn memcpy_8() {
        test_memcpy(8, 0, 8);
    }

    #[test]
    /// Test `memcpy` with a length of 16 bytes.
    fn memcpy_16() {
        test_memcpy(16, 0, 16);
    }

    #[test]
    /// Test `memcpy` with a length of 24 bytes.
    fn memcpy_24() {
        test_memcpy(24, 0, 24);
    }

    #[test]
    /// Test `memcpy` with a length of 32 bytes.
    fn memcpy_32() {
        test_memcpy(32, 0, 32);
    }

    #[test]
    /// Test `memcpy` with a length of 40 bytes.
    fn memcpy_40() {
        test_memcpy(40, 0, 40);
    }

    #[test]
    /// Test `memcpy` with a length of 48 bytes.
    fn memcpy_48() {
        test_memcpy(48, 0, 48);
    }

    #[test]
    /// Test `memcpy` with a length of 64 bytes.
    fn memcpy_64() {
        test_memcpy(64, 0, 64);
    }

    #[test]
    /// Test `memcpy` with a length of 128 bytes.
    fn memcpy_128() {
        test_memcpy(128, 0, 128);
    }
}


pub fn __llvm_memcpy_p0_p0_p_p_c_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_b_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_z_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_x_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_i_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_n_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_k_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_l_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}

pub fn __llvm_memcpy_p0_p0_p_p_o_c_v(
    ref state: RTState, dest: Address, src: Address, len: u128, _is_volatile: u128,
) {
    memcpy(ref state.allocator, dest, src, len);
}
