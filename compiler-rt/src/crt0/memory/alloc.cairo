use super::super::allocator::{AllocatorState, AllocatorOps, Address};
use super::get_allocator;

/// Allocate a contiguous region of `size_bytes * count` bytes of memory, and return a pointer to
/// the start of that memory region.
///
/// Both `size_bytes` and `count` must be non-negative and their product must fit in u64.
///
/// See compiler_rt::crt0::allocator::AllocatorOps::allocate for details about memory allocation.
///
/// This is the implementation of the `__llvm_alloc_*` polyfills logic. It exists so that it can be
/// unit-tested with a mock allocator. The polyfills are wrappers over this function and they get
/// the actual allocator with the getter generated by Hieratika.
fn alloc(ref allocator: AllocatorState, size_bytes: i64, count: i64) -> Address {
    let size_bytes: u64 = size_bytes.try_into().expect('size_bytes does not fit u64');
    let count: u64 = count.try_into().expect('count does not fit u64');
    allocator.allocate(size_bytes * count)
}

#[cfg(test)]
mod test {
    use super::alloc;
    use crate::crt0::allocator::Allocator;

    #[test]
    /// Check if the allocation described by `size_bytes` and `count` parameters returns a region
    /// of `size_bytes * count` bytes.
    fn size_times_count() {
        // Create an allocator to be used in the test.
        let mut allocator = Allocator::new();

        // Allocate the region of 37 portions by 21 bytes each.
        let addr1 = alloc(ref allocator, 21, 37);
        // The first region should be allocated at the beginning of the memory pool.
        assert_eq!(addr1, 0);

        // Allocate the next region of 1 byte.
        let addr2 = alloc(ref allocator, 1, 1);
        // The second region should be allocated right after the first region consisting of 21 * 37
        // bytes, therefore its address should be 27 * 37.
        assert_eq!(addr2, 21 * 37);
    }
}

pub fn __llvm_alloc_l_l_p(size_bytes: i64, count: i64) -> Address {
    let mut allocator = get_allocator().unbox();
    alloc(ref allocator, size_bytes, count)
}
