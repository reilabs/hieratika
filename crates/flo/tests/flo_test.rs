//! High level functional tests for direct use of `FlatLoweredObject`s.
//! Covers flo.rs, types.rs, and bUilders.rs

use std::str::FromStr;

use hieratika_flo::{
    types::{const_u32, Signature, Type},
    FlatLoweredObject,
};

#[test]
fn flos_are_the_same_after_round_trip() -> anyhow::Result<()> {
    let mut flo = FlatLoweredObject::new("test");

    // Simple factorial test program.
    //
    // This is equivalent to fact(x) -> eq_u32_u32(x, 0) ? 1 : mul_u32_u32(x,
    // fact(sub_u32_u32(x, 1))), with multiplication, subtraction and equality
    // checking performed by fictitious compiler functions.

    // Create the function signature...
    let fact_input = flo.add_variable(Type::Unsigned32);
    let fact_output = flo.add_variable(Type::Unsigned32);
    let fact_signature = Signature {
        params:   vec![fact_input],
        returns:  vec![fact_output],
        location: None,
    };

    // ... create the blocks we'll use for the zero and non-zero branch; we'll fill
    // them later.
    let block_is_zero = flo.new_empty_block();
    let block_is_nonzero = flo.new_empty_block();

    // Create the function entry point that will implement the initial equality
    // comparison, and then branch to the other blocks.
    flo.add_function(&fact_signature, |b| -> anyhow::Result<()> {
        // Create a constant value of zero.
        let zero = b.add_variable(Type::Unsigned32);
        b.simple_assign_const(zero, const_u32(0));

        // Perform our equality comparison.
        let equals_zero = b.add_variable(Type::Bool);
        b.simple_call_builtin("eq_u32_u32", vec![fact_input, zero], vec![equals_zero]);

        // Finally, branch to either the is-zero or non-zero path.
        b.end_with_if(equals_zero, block_is_zero, block_is_nonzero, None);

        Ok(())
    })?;

    // In the zero path, we have a bock that just returns '1'.
    flo.fill_block(block_is_zero, None, |b| -> anyhow::Result<()> {
        // Create the return value of '1'...
        let retval = b.add_variable(Type::Unsigned32);
        b.simple_assign_const(retval, const_u32(1));

        // ... and end the block by returning!
        b.end_with_return(vec![retval]);

        Ok(())
    })?;

    // In the non-zero path, we compute mul(i, sub(i, 1)), and return that.
    flo.fill_block(block_is_nonzero, None, |b| -> anyhow::Result<()> {
        // Create the '1' we'll use in subtract...
        let const_one = b.add_variable(Type::Unsigned32);
        b.simple_assign_const(const_one, const_u32(1));

        // ... and perform the subtraction to compute i - 1.
        let i_minus_one = b.add_variable(Type::Unsigned32);
        b.simple_call_builtin(
            "sub_u32_u32",
            vec![fact_input, const_one],
            vec![i_minus_one],
        );

        // Finally, we'll multiply i and i - 1...
        let final_value = b.add_variable(Type::Unsigned32);
        b.simple_call_builtin(
            "mul_u32_u32",
            vec![fact_input, i_minus_one],
            vec![final_value],
        );

        // ... and return the result.
        b.end_with_return(vec![final_value]);

        Ok(())
    })?;

    // Finally, serialize the result, and validate that it matches the hand-made
    // file we expect from the calls.
    let resultant_sexp = flo
        .to_str()
        .expect("the sample function should generate valid sexprs");

    // TODO(ktemkin): once we have sorted sexpr rendering, we can either compare
    // sexpr strings (brittle, and what this test originally did), or we can
    // build a simple visitor that walks the trees and makes sure they're the same.

    // Deserialized
    //

    let restored_flo = FlatLoweredObject::from_str(&resultant_sexp)
        .expect("FLOs generated by Hieratika should be readable by Hieratika");
    assert_eq!(
        restored_flo, flo,
        "flo should serialize and deserialize to be the same!"
    );

    Ok(())
}
